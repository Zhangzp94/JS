##### 01 什么是DOM？





##### 02 什么是执行上下文？

什么是执行上下文？执行上下文的创建和执行阶段是怎么样的？

- https://juejin.im/post/5ba32171f265da0ab719a6d7

***详解创建阶段的流程图***

1. **this** 值的决定，即我们所熟知的 **This 绑定**。
2. 创建**词法环境**组件。
3. 创建**变量环境**组件。

***词法环境***



![2](..\image\2.png)

![3](..\image\3.png)



***变量环境***

````js
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);
````



![4](..\image\4.png)



**补充**

上图执行上下文的环境记录器

*左边是*  全局变量环境记录器，是在全局执行上下文中，里面的LexicalEnviroment（**其实就是词法环境**）记录const let 还有**函数**！当这里记录到有函数了，就自动创建右边的函数执行上下文！ VariableEnviroment（**其实就是变量环境**）记录比如var 变量!

*右边是*  声明式环境记录器 ， 是在函数全局执行上下文中 ， 里面的LexicalEnviroment（**其实就是词法环境**）记录const let 还有**函数参数**的！ VariableEnviroment（**其实就是变量环境**）记录比如var 变量!



**注意** — 只有遇到调用函数 `multiply` 时，函数执行上下文才会被创建。

可能你已经注意到 `let` 和 `const` 定义的变量并没有关联任何值，但 `var` 定义的变量被设成了 `undefined`。

这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 `undefined`（`var` 情况下），或者未初始化（`let` 和 `const` 情况下）。这里就是我理解的创建阶段只记录声明不赋值！

这就是为什么你可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`），但是在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。

这就是我们说的变量声明提升。



***面试答题：***

执行上下文简而言之就是js代码当前的运行环境，有三种类型，**全局执行上下文、函数执行上下文、Eval执行上下文**。

全局执行上下文：是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 `this` 的值等于这个全局对象。

函数执行上下文： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。可以用执行栈的例子说明。

**执行栈**

可以把这里的执行栈看成一个空的薯片盒子，当js引擎首次执行脚本的时候，先创建一个全局执行上下文到执行栈底部，然后遇到一个函数调用，就会自动创建一个函数执行上下文到执行栈底部，依次叠加，比如函数A嵌套函数B，函数B嵌套函数C，调用函数A的时候，就是先创建函数执行上下文A，放入执行栈顶部，再创建函数执行上下文B放入执行栈顶部，再创建函数执行上下文C放入执行栈顶部，这就是***执行上下文的创建阶段***。

**那么创建阶段经历了哪些事情呢？**

1.**this** 值的决定，即 **This 绑定**。2.创建**词法环境**组件。3.创建**变量环境**组件。

创建阶段分为全局环境和函数环境，就是全局执行上下文和函数执行上下文，2个环境都有环境记录器，全局上下文中的是全局变量环境记录器，函数上下文中的是声明式环境记录器。2种环境记录器内部都有词法环境和变量环境，简单来说词法环境就是记录const let绑定 和 定义的函数，补充说明的是函数环境下，环境记录器中的词法环境还可以记录传递给函数的 `arguments` 对象，就是参数的映射和参数的length！而变量环境记录的是 `var` 变量绑定。 

最后↓

***执行阶段***完成对所有这些变量的分配，最后执行代码。



##### 03 js执行机制

js执行的时候 同步的代码会按照执行顺序顺序执行，遇到异步代码的时候，属于宏任务的放到宏队列，微任务放到微队列，包括setTimeOut、setInterval等也属于宏任务，promise、 process.nextTick属于微任务；执行完一个宏任务后，直接执行所有的微任务，再执行第二个宏任务......

https://juejin.im/post/59e85eebf265da430d571f89#heading-10



##### 04 js防抖 节流

**防抖：**在事件被触发n秒后再执行**回调**，如果在这n秒内又被触发，则重新计时。

https://juejin.im/post/5b8de829f265da43623c4261#heading-2



就是一个事件每间隔一段时间触发一次，可以多次触发。类似于scroll 事件滚动滑轮就会触发事件，防抖就是让它每间隔一段时间再进行触发，降低触发频率。

防抖的奥妙在于定时器的运用，当你事件不断触发的时候，比如1s触发一次，然后调用带有定时器的函数。只要在你设置的时间内触发事件，调用的时候都需要重新计算

先了解下面一段代码

```js
下面这段代码，是不会log出来的，因为2200ms>1000ms，每次调用的时候都重新计算了！
function fn1() {
    clearTimeout(timer)
    timer = setTimeout(()=>{
        console.log(111)
    },2200)
}
setInterval(function () {
    fn1()
},1000)
```

例子：

```js
<script>
    var input = document.getElementById("input")
    function ajax(content) {
        console.log('ajax:'+content)
    }
    function model(fn,daley=300) {
        //var timer = null
        return function (content) {
            clearTimeout(fn.id)
            fn.id = setTimeout(()=> {
                fn(content); // 事件触发2000ms后 执行这个回调！ 精髓就是这里！
            },daley)
        }
    }
    let res =  model(ajax,2000)
    input.addEventListener('keyup',function (e) {
        res(e.target.value)
    })
</script>
```



**函数节流：**规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

比如 规定控制在1s时间 执行一次函数！